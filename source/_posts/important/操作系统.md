---
title: 操作系统
toc: true
date: 2021-12-24 10:58:17
# thumbnail: /images/2021/岁月的童话2.jpg7.1.1
tags:
  - other
  - blog
categories:
  - other

---

- [引论](#引论)
  - [1 引论](#1-引论)
- [二 进程管理](#二-进程管理)
  - [2 进程管理](#2-进程管理)
  - [2.1.4程序的三态](#214程序的三态)
    - [2.1.5](#215)
    - [2.3.1.4 同步机制应遵循的规则](#2314-同步机制应遵循的规则)
    - [2.3.2 信号量机制](#232-信号量机制)
    - [2.3.3 信号量的应用](#233-信号量的应用)
    - [2.6.4 线程的实现](#264-线程的实现)
- [三 处理机调度与死锁](#三-处理机调度与死锁)
  - [3.3 调 度 算 法](#33-调-度-算-法)
    - [3.2.1 先来先服务和短作业(进程)优先调度算法](#321-先来先服务和短作业进程优先调度算法)
    - [3.3.2 高优先权优先调度算法](#332-高优先权优先调度算法)
    - [3.5.2 产生死锁的必要条件](#352-产生死锁的必要条件)
    - [3.5.3 处理死锁的基本方法](#353-处理死锁的基本方法)
- [第四章 存 储 器 管 理](#第四章-存-储-器-管-理)
  - [。。。](#)
    - [4.3.3 动态分区分配](#433-动态分区分配)
  - [4.4 基本分页存储管理方式](#44-基本分页存储管理方式)
    - [4.4.1 页面与页表](#441-页面与页表)
    - [4.4.2 地址变换机构](#442-地址变换机构)
  - [4.5 基本分段存储管理方式](#45-基本分段存储管理方式)
    - [4.5.2 分段系统的基本原理](#452-分段系统的基本原理)

<!--more-->
# 引论

## 1 引论

----

# 二 进程管理


## 2 进程管理

## 2.1.4程序的三态

- 就绪态
- 执行状态
- 阻塞状态


### 2.1.5

> PCB (PROCESS CONTROL BLOCK) 


### 2.3.1.4 同步机制应遵循的规则

- 空闲让进。当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源
- 忙则等待。当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。
- 有限等待。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态
- 让权等待。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。

> 让权等待可以对比循环查询，和队列触发这两者比较。前者永远在不停的检测是否可以使用，后者则是通过事件，当任务执行完毕后自动调用阻塞的任务。

### 2.3.2 信号量机制

- P 通过
- V 释放
- wait()
- signl()

### 2.3.3 信号量的应用
- 1．利用信号量实现进程互
- 2．利用信号量实现前趋关系
  
### 2.6.4 线程的实现

用户级线程与内核控制线程的连接
- 1v1
- nv1
- nvn

# 三 处理机调度与死锁

## 3.3 调 度 算 法
### 3.2.1 先来先服务和短作业(进程)优先调度算法
- 先来先服务
- 短作业优先 
  - 饥饿
  
### 3.3.2 高优先权优先调度算法
### 3.5.2 产生死锁的必要条件
- 互斥条件
- 请求和保持条件
- 不剥夺条件
- 环路等待条件
### 3.5.3 处理死锁的基本方法
- 预防死锁
- 避免死锁
- 检测死锁
- 解除死锁

# 第四章 存 储 器 管 理
## 。。。
### 4.3.3 动态分区分配
 分区分配中的数据结构
- 空闲分区表
- 空闲分区链

 分区分配算法
- 首次适应算法(first fit) 
  - 求空闲分区链以地址递增的次序链接，分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止。
- 循环首次适应算法(next fit)
  - 不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区。
- 最佳适应算法(best fit)
  - 把能满足要求、又是最小的空闲分区分配给作业
- 最坏适应算法(worst fit) 
  - 最坏适应分配算法要扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给作业使用
- 快速适应算法(quick fit)

> 碎片 内/外碎片  整体无法使用的的块儿（外部），和分配块儿后，块儿内无法使用的部分（内部）。

## 4.4 基本分页存储管理方式
### 4.4.1 页面与页表
> 逻辑分块成为页或者页面，对应内存分的(物理)块或页框(frame)，两者大小相同
> 由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。
- 分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从 0 开始，如第 0 页、第 1 页等。相应地，也把内存空间分成与页面相同大小的若干个存储块，称为(物理)块或页框(frame)，也同样为它们加以编号，如 0#块、1#块等等。
> 页面若太小，一方面虽然可使内存碎片减小，从而减少了内存碎片的总空间，有利于提高内存利用率，但另一方面也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存
> 如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大

> 地址结构:    
> ｜页号 P ｜位移量 W ｜    
> 31～12，11～0    

> 页号 P 和页内地址 d   
> P=int(A/L)    
> d=[A] MOD L  

页表:  
> 逻辑地址到物理地址的映射表
页号｜块号


### 4.4.2 地址变换机构
> 页表位于内存
> 联想寄存器-快表-TLB

- [ ] reread
**两级页表**  144 页

## 4.5 基本分段存储管理方式

### 4.5.2 分段系统的基本原理

段号｜段内地址

段表

LOAD 1，[A] |〈D〉;
STORE 1，[B] |〈C〉;






